import {
  GraphQLEnumType,
  GraphQLField,
  GraphQLInputField,
  GraphQLInputObjectType,
  GraphQLInterfaceType,
  GraphQLList,
  GraphQLNamedType,
  GraphQLNonNull,
  GraphQLNullableType,
  GraphQLObjectType,
  GraphQLScalarType,
  GraphQLType,
  GraphQLUnionType,
} from "graphql/type/definition";
import { specifiedScalarTypes } from "graphql/type/scalars";
import { introspectionTypes } from "graphql/type/introspection";

import { GraphQLSchema } from "graphql/type/schema";

export type PrinterOptions = {
  readonly: boolean;
};

const introspectionTypeNames = new Set(
  introspectionTypes.map((type) => type.name)
);

const builtinScalars: Record<string, string> = {
  ID: "string",
  String: "string",
  Boolean: "boolean",
  Int: "number",
  Float: "number",
};

export type SchemaPrinterOptions = {
  schema: GraphQLSchema;
  readonly: boolean;
  scalars: Record<string, string>;
};

const deprecatedComment = `/** @deprecated This should not be used outside of code generated by ts-gql */`;

// the helper types are from GraphQL Code Generator so that when it
// generates the operation types, it has them available
const header = `${deprecatedComment}
export type Maybe<T> = T | null;
${deprecatedComment}
export type InputMaybe<T> = Maybe<T>;
${deprecatedComment}
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
${deprecatedComment}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
${deprecatedComment}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

${deprecatedComment}
export type Scalars = {
`;

type InternalPrinterOptions = {
  inlinables: Map<string, string>;
  readonly: boolean;
};

export function printSchemaTypes(options: SchemaPrinterOptions) {
  const { schema } = options;
  let output = "";
  const allScalars: Record<string, string> = {
    ...builtinScalars,
    ...options.scalars,
  };
  const inlinables = new Map<string, string>();
  for (const builtin of specifiedScalarTypes) {
    if (options.scalars[builtin.name] === undefined) {
      inlinables.set(builtin.name, builtinScalars[builtin.name]);
    }
  }
  const internalOptions: InternalPrinterOptions = {
    inlinables,
    readonly: options.readonly,
  };

  const typeMap = schema.getTypeMap();
  const allTypes: Set<GraphQLNamedType> = new Set(specifiedScalarTypes);
  const types = Object.values(typeMap);
  for (const type of types) {
    allTypes.add(type);
  }
  let scalarsOutput = "";
  for (const type of allTypes) {
    if (introspectionTypeNames.has(type.name)) continue;
    if (type instanceof GraphQLEnumType) {
      output += "\n\n" + printEnumType(type);
    }
    if (type instanceof GraphQLInputObjectType) {
      output += "\n\n" + printInputObjectType(type, internalOptions);
    }
    if (type instanceof GraphQLObjectType) {
      output += "\n\n" + printObjectType(type, internalOptions);
    }
    if (type instanceof GraphQLInterfaceType) {
      output += "\n\n" + printInterfaceType(type, internalOptions);
    }
    if (
      type instanceof GraphQLObjectType ||
      type instanceof GraphQLInterfaceType
    ) {
      for (const field of Object.values(type.getFields())) {
        if (field.args.length === 0) continue;
        output +=
          "\n\n" +
          `export type ${type.name}${field.name}Args = {\n${printInputFields(
            field.args,
            internalOptions
          )}\n};`;
      }
    }
    if (type instanceof GraphQLUnionType) {
      output +=
        "\n\n" +
        `export type ${type.name} = ${type
          .getTypes()
          .map((type) => type.name)
          .join(" | ")};`;
    }

    if (type instanceof GraphQLScalarType) {
      const inlinedContent = inlinables.get(type.name);
      if (inlinedContent !== undefined) {
        scalarsOutput += `  ${type.name}: ${inlinedContent};\n`;
        continue;
      }
      output +=
        "\n\n" +
        `export type ${type.name} = ${allScalars[type.name] ?? "any"};`;

      scalarsOutput += `  ${type.name}: ${type.name};\n`;
      continue;
    }
  }
  return (
    header +
    scalarsOutput +
    "};" +
    output +
    `\n\ntype TSGQLMaybeArray<T> = ${
      options.readonly ? "ReadonlyArray" : "Array"
    }<T> | T\n\nexport {};`
  );
}

function printInputObjectType(
  type: GraphQLInputObjectType,
  options: InternalPrinterOptions
) {
  if (type.isOneOf) {
    return `export type ${type.name} = {\n${Object.values(type.getFields())
      .map((field) =>
        printInputFields(
          [{ ...field, type: new GraphQLNonNull(field.type) }],
          options
        )
      )
      .join("\n} | {\n")}\n};`;
  }
  return `export type ${type.name} = {\n${printInputFields(
    Object.values(type.getFields()),
    options
  )}\n};`;
}

function printObjectType(
  type: GraphQLObjectType,
  options: InternalPrinterOptions
) {
  return `export type ${type.name} = {\n  ${
    options.readonly ? "readonly " : ""
  }__typename: ${JSON.stringify(type.name)};\n${printOutputFields(
    Object.values(type.getFields()),
    options
  )}\n};`;
}

function printInterfaceType(
  type: GraphQLInterfaceType,
  options: InternalPrinterOptions
) {
  return `export type ${type.name} = {\n${printOutputFields(
    Object.values(type.getFields()),
    options
  )}\n};`;
}

function printOutputFields(
  fields: GraphQLField<any, any>[],
  options: InternalPrinterOptions
) {
  const readonlyPart = options.readonly ? "readonly " : "";
  return fields
    .map(
      (field) =>
        `  ${readonlyPart}${field.name}: ${printTypeReference(
          field.type,
          options,
          "output"
        )};`
    )
    .join("\n");
}

function printInputFields(
  fields: readonly GraphQLInputField[],
  options: InternalPrinterOptions
) {
  const readonlyPart = options.readonly ? "readonly " : "";
  return fields
    .map(
      (field) =>
        `  ${readonlyPart}${field.name}${
          field.type instanceof GraphQLNonNull &&
          field.defaultValue === undefined
            ? ""
            : "?"
        }: ${printTypeReference(field.type, options, "input")};`
    )
    .join("\n");
}

function printEnumType(type: GraphQLEnumType) {
  return `export type ${type.name} =\n${type
    .getValues()
    .map((value) => `  | "${value.name}"`)
    .join("\n")};`;
}

function printTypeReferenceWithoutNullability(
  type: GraphQLNullableType,
  options: InternalPrinterOptions,
  mode: "input" | "output"
): string {
  if (type instanceof GraphQLList) {
    return `${
      mode === "input"
        ? "TSGQLMaybeArray"
        : options.readonly
        ? "ReadonlyArray"
        : "Array"
    }<${printTypeReference(type.ofType, options, mode)}>`;
  }
  const inline = options.inlinables.get(type.name);
  if (inline !== undefined) {
    return inline;
  }
  return type.name;
}

function printTypeReference(
  type: GraphQLType,
  options: InternalPrinterOptions,
  mode: "input" | "output"
): string {
  if (type instanceof GraphQLNonNull) {
    return printTypeReferenceWithoutNullability(type.ofType, options, mode);
  }
  const inner = printTypeReferenceWithoutNullability(type, options, mode);
  return `${inner} | null`;
}
